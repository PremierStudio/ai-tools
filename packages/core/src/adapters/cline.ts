import { BaseAdapter, registry } from "./index.js";
import type {
  AdapterCapabilities,
  GeneratedConfig,
  HookDefinition,
  HookEventType,
} from "../types/index.js";
import { resolve } from "node:path";
import { existsSync } from "node:fs";

/**
 * Event mapping: ai-hooks universal events -> Cline native hooks.
 *
 * Cline supports seven hook events (since v3.36):
 *   PreToolUse, PostToolUse, UserPromptSubmit,
 *   TaskStart, TaskResume, TaskCancel, PreCompact
 *
 * Hook scripts are executables in .clinerules/hooks/ (project) or
 * ~/Documents/Cline/Rules/Hooks/ (global). They receive JSON via STDIN
 * and return JSON via STDOUT. The `cancel` field in output blocks
 * PreToolUse actions.
 *
 * Reference: https://docs.cline.bot/features/hooks
 */
const EVENT_MAP: Record<string, string[]> = {
  "session:start": ["TaskStart"],
  "session:end": ["TaskCancel"],
  "prompt:submit": ["UserPromptSubmit"],
  "prompt:response": [],
  "tool:before": ["PreToolUse"],
  "tool:after": ["PostToolUse"],
  "file:read": ["PreToolUse"],
  "file:write": ["PreToolUse"],
  "file:edit": ["PreToolUse"],
  "file:delete": ["PreToolUse"],
  "shell:before": ["PreToolUse"],
  "shell:after": ["PostToolUse"],
  "mcp:before": ["PreToolUse"],
  "mcp:after": ["PostToolUse"],
  notification: [],
};

const REVERSE_MAP: Record<string, HookEventType[]> = {
  TaskStart: ["session:start"],
  TaskCancel: ["session:end"],
  TaskResume: ["session:start"],
  UserPromptSubmit: ["prompt:submit"],
  PreToolUse: [
    "tool:before",
    "file:read",
    "file:write",
    "file:edit",
    "file:delete",
    "shell:before",
    "mcp:before",
  ],
  PostToolUse: ["tool:after", "shell:after", "mcp:after"],
  PreCompact: [],
};

/**
 * Cline adapter for ai-hooks.
 *
 * Generates executable hook scripts in `.clinerules/hooks/` that delegate
 * to the ai-hooks runtime. Cline hooks receive JSON via STDIN containing
 * operation context (pendingToolInfo, etc.) and return JSON via STDOUT
 * with `cancel` boolean to block actions.
 *
 * Reference: https://docs.cline.bot/features/hooks
 */
class ClineAdapter extends BaseAdapter {
  readonly id = "cline";
  readonly name = "Cline";
  readonly version = "1.0";

  readonly capabilities: AdapterCapabilities = {
    beforeHooks: true,
    afterHooks: true,
    mcp: true,
    configFile: true,
    supportedEvents: [
      "session:start",
      "session:end",
      "prompt:submit",
      "tool:before",
      "tool:after",
      "file:read",
      "file:write",
      "file:edit",
      "file:delete",
      "shell:before",
      "shell:after",
      "mcp:before",
      "mcp:after",
    ],
    blockableEvents: [
      "tool:before",
      "file:read",
      "file:write",
      "file:edit",
      "file:delete",
      "shell:before",
      "mcp:before",
    ],
  };

  async detect(): Promise<boolean> {
    const hasCommand = await this.commandExists("cline");
    const hasDir = existsSync(resolve(process.cwd(), ".clinerules"));
    return hasCommand || hasDir;
  }

  async generate(hooks: HookDefinition[]): Promise<GeneratedConfig[]> {
    const configs: GeneratedConfig[] = [];

    // Collect needed native events
    const neededEvents = new Set<string>();
    for (const hook of hooks) {
      for (const event of hook.events) {
        const nativeEvents = this.mapEvent(event);
        for (const ne of nativeEvents) {
          neededEvents.add(ne);
        }
      }
    }

    // Generate one executable script per needed hook event
    for (const event of neededEvents) {
      configs.push({
        path: `.clinerules/hooks/${event}`,
        content: this.generateHookScript(event),
        format: "js",
      });
    }

    return configs;
  }

  mapEvent(event: HookEventType): string[] {
    return EVENT_MAP[event] ?? [];
  }

  mapNativeEvent(nativeEvent: string): HookEventType[] {
    return REVERSE_MAP[nativeEvent] ?? [];
  }

  async uninstall(): Promise<void> {
    const hookNames = [
      "PreToolUse",
      "PostToolUse",
      "UserPromptSubmit",
      "TaskStart",
      "TaskResume",
      "TaskCancel",
      "PreCompact",
    ];
    for (const name of hookNames) {
      await this.removeFile(`.clinerules/hooks/${name}`);
    }
  }

  private generateHookScript(eventName: string): string {
    return `#!/usr/bin/env node
/**
 * ai-hooks runner for Cline (${eventName}).
 * Generated by: ai-hooks generate
 *
 * Cline passes hook event data as JSON via STDIN with:
 *   hookName, taskId, workspaceRoots, pendingToolInfo, etc.
 *
 * Output JSON with { cancel: true, errorMessage: "..." } to block.
 * Output JSON with { cancel: false } to allow.
 *
 * DO NOT EDIT - regenerate with: ai-hooks generate
 */
import { loadConfig, HookEngine } from "@premierstudio/ai-hooks";

async function readStdin() {
  const chunks = [];
  for await (const chunk of process.stdin) {
    chunks.push(chunk);
  }
  return Buffer.concat(chunks).toString("utf-8");
}

async function run() {
  const raw = await readStdin();
  const input = JSON.parse(raw || "{}");
  const hookName = input.hookName ?? "${eventName}";
  const pendingToolInfo = input.pendingToolInfo ?? {};
  const toolName = pendingToolInfo.toolName ?? "";

  const config = await loadConfig();
  const engine = new HookEngine(config);
  const toolInfo = { name: "cline", version: "1.0" };
  const timestamp = Date.now();
  const metadata = { taskId: input.taskId ?? "" };

  let event;
  switch (hookName) {
    case "TaskStart":
    case "TaskResume":
      event = {
        type: "session:start",
        tool: "cline",
        version: "1.0",
        workingDirectory: (input.workspaceRoots ?? [])[0] ?? process.cwd(),
        timestamp,
        metadata,
      };
      break;
    case "TaskCancel":
      event = { type: "session:end", tool: "cline", duration: 0, timestamp, metadata };
      break;
    case "UserPromptSubmit":
      event = { type: "prompt:submit", prompt: input.userMessage ?? "", timestamp, metadata };
      break;
    case "PreToolUse":
      event = resolvePreToolEvent(toolName, pendingToolInfo, timestamp, metadata);
      break;
    case "PostToolUse":
      event = resolvePostToolEvent(toolName, pendingToolInfo, timestamp, metadata);
      break;
    default:
      process.stdout.write(JSON.stringify({ cancel: false }));
      process.exit(0);
  }

  const results = await engine.emit(event, toolInfo);
  const blocked = results.find((r) => r.blocked);

  if (blocked) {
    process.stdout.write(JSON.stringify({
      cancel: true,
      errorMessage: blocked.reason ?? "Blocked by ai-hooks",
    }));
    process.exit(0);
  }

  process.stdout.write(JSON.stringify({ cancel: false }));
}

function resolvePreToolEvent(toolName, info, timestamp, metadata) {
  switch (toolName) {
    case "write_to_file":
      return { type: "file:write", path: info.path ?? "", content: info.content ?? "", timestamp, metadata };
    case "replace_in_file":
      return { type: "file:edit", path: info.path ?? "", oldContent: info.diff ?? "", newContent: "", timestamp, metadata };
    case "read_file":
      return { type: "file:read", path: info.path ?? "", timestamp, metadata };
    case "execute_command":
      return { type: "shell:before", command: info.command ?? "", cwd: process.cwd(), timestamp, metadata };
    case "use_mcp_tool":
      return { type: "mcp:before", server: info.mcpServer ?? "", tool: info.mcpTool ?? "", input: {}, timestamp, metadata };
    default:
      return { type: "tool:before", toolName: toolName || "unknown", input: info, timestamp, metadata };
  }
}

function resolvePostToolEvent(toolName, info, timestamp, metadata) {
  switch (toolName) {
    case "execute_command":
      return {
        type: "shell:after",
        command: info.command ?? "",
        cwd: process.cwd(),
        exitCode: 0,
        stdout: "",
        stderr: "",
        duration: 0,
        timestamp,
        metadata,
      };
    default:
      return { type: "tool:after", toolName: toolName || "unknown", input: info, output: {}, duration: 0, timestamp, metadata };
  }
}

run().catch((err) => {
  console.error("[ai-hooks] Error:", err.message);
  process.stdout.write(JSON.stringify({ cancel: false }));
  process.exit(0);
});
`;
  }
}

// Auto-register
const adapter = new ClineAdapter();
registry.register(adapter);

export { ClineAdapter };
export default adapter;
