import { BaseAdapter, registry } from "./index.js";
import type {
  AdapterCapabilities,
  GeneratedConfig,
  HookDefinition,
  HookEventType,
} from "../types/index.js";
import { existsSync } from "node:fs";
import { resolve } from "node:path";

/**
 * Event mapping: ai-hooks -> Gemini CLI native hooks.
 *
 * Gemini CLI uses GEMINI_HOOKS_DIR with event-named scripts.
 * Reference: https://github.com/google/gemini-cli
 */
const EVENT_MAP: Record<string, string[]> = {
  "session:start": ["SessionStart"],
  "session:end": ["SessionEnd"],
  "prompt:submit": ["BeforePrompt"],
  "prompt:response": ["AfterResponse"],
  "tool:before": ["BeforeTool"],
  "tool:after": ["AfterTool"],
  "file:write": ["BeforeTool"], // FileWrite tool
  "file:edit": ["BeforeTool"], // FileEdit tool
  "file:delete": ["BeforeTool"], // FileDelete tool
  "shell:before": ["BeforeShell"],
  "shell:after": ["AfterShell"],
  "mcp:before": ["BeforeTool"],
  "mcp:after": ["AfterTool"],
};

const REVERSE_MAP: Record<string, HookEventType[]> = {
  SessionStart: ["session:start"],
  SessionEnd: ["session:end"],
  BeforePrompt: ["prompt:submit"],
  AfterResponse: ["prompt:response"],
  BeforeTool: ["tool:before", "file:write", "file:edit", "file:delete", "mcp:before"],
  AfterTool: ["tool:after", "mcp:after"],
  BeforeShell: ["shell:before"],
  AfterShell: ["shell:after"],
};

class GeminiCliAdapter extends BaseAdapter {
  readonly id = "gemini-cli";
  readonly name = "Gemini CLI";
  readonly version = "1.0";

  readonly capabilities: AdapterCapabilities = {
    beforeHooks: true,
    afterHooks: true,
    mcp: true,
    configFile: true,
    supportedEvents: [
      "session:start",
      "session:end",
      "prompt:submit",
      "prompt:response",
      "tool:before",
      "tool:after",
      "file:write",
      "file:edit",
      "file:delete",
      "shell:before",
      "shell:after",
      "mcp:before",
      "mcp:after",
    ],
    blockableEvents: [
      "prompt:submit",
      "tool:before",
      "file:write",
      "file:edit",
      "file:delete",
      "shell:before",
      "mcp:before",
    ],
  };

  async detect(): Promise<boolean> {
    const hasCommand = await this.commandExists("gemini");
    const hasConfig = existsSync(resolve(process.cwd(), ".gemini"));
    return hasCommand || hasConfig;
  }

  async generate(hooks: HookDefinition[]): Promise<GeneratedConfig[]> {
    const configs: GeneratedConfig[] = [];

    // Gemini CLI uses a hooks directory with scripts named by event
    const neededEvents = new Set<string>();
    for (const hook of hooks) {
      for (const event of hook.events) {
        const nativeEvents = this.mapEvent(event);
        for (const ne of nativeEvents) {
          neededEvents.add(ne);
        }
      }
    }

    // Generate a hook script for each needed event
    for (const event of neededEvents) {
      configs.push({
        path: `.gemini/hooks/${event}.js`,
        content: this.generateEventScript(event),
        format: "js",
      });
    }

    // Generate settings to enable hooks
    configs.push({
      path: ".gemini/settings.json",
      content:
        JSON.stringify(
          {
            hooks: {
              enabled: true,
              directory: ".gemini/hooks",
            },
          },
          null,
          2,
        ) + "\n",
      format: "json",
    });

    return configs;
  }

  mapEvent(event: HookEventType): string[] {
    return EVENT_MAP[event] ?? [];
  }

  mapNativeEvent(nativeEvent: string): HookEventType[] {
    return REVERSE_MAP[nativeEvent] ?? [];
  }

  async uninstall(): Promise<void> {
    // Remove hook scripts
    for (const event of Object.keys(REVERSE_MAP)) {
      await this.removeFile(`.gemini/hooks/${event}.js`);
    }
  }

  private generateEventScript(nativeEvent: string): string {
    return `#!/usr/bin/env node
/**
 * ai-hooks runner for Gemini CLI (${nativeEvent}).
 * Generated by: ai-hooks generate
 */
import { loadConfig, HookEngine } from "@premierstudio/ai-hooks";

const input = JSON.parse(process.env.GEMINI_HOOK_INPUT ?? "{}");

async function run() {
  const config = await loadConfig();
  const engine = new HookEngine(config);
  const toolInfo = { name: "gemini-cli", version: "1.0" };
  const timestamp = Date.now();
  const metadata = {};

  let event;
  switch ("${nativeEvent}") {
    case "SessionStart":
      event = { type: "session:start", tool: "gemini-cli", version: "1.0", workingDirectory: process.cwd(), timestamp, metadata };
      break;
    case "BeforeShell":
      event = { type: "shell:before", command: input.command ?? "", cwd: process.cwd(), timestamp, metadata };
      break;
    case "BeforeTool":
      event = { type: "tool:before", toolName: input.toolName ?? "unknown", input, timestamp, metadata };
      break;
    case "BeforePrompt":
      event = { type: "prompt:submit", prompt: input.prompt ?? "", timestamp, metadata };
      break;
    default:
      event = { type: "tool:after", toolName: "${nativeEvent}", input, output: {}, duration: 0, timestamp, metadata };
  }

  const results = await engine.emit(event, toolInfo);
  const blocked = results.find((r) => r.blocked);

  if (blocked) {
    console.log(JSON.stringify({ blocked: true, reason: blocked.reason }));
    process.exit(1);
  }
}

run().catch(() => process.exit(1));
`;
  }
}

const adapter = new GeminiCliAdapter();
registry.register(adapter);

export { GeminiCliAdapter };
export default adapter;
