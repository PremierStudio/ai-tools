import { BaseAdapter, registry } from "./index.js";
import type {
  AdapterCapabilities,
  GeneratedConfig,
  HookDefinition,
  HookEventType,
} from "../types/index.js";
import { resolve } from "node:path";
import { existsSync } from "node:fs";
import { readFile } from "node:fs/promises";

/**
 * Event mapping: ai-hooks universal events -> Claude Code native hooks.
 */
const EVENT_MAP: Record<string, string[]> = {
  "session:start": ["SessionStart"],
  "session:end": [],
  "prompt:submit": ["UserPromptSubmit"],
  "prompt:response": ["PostToolUse"], // approximate - Claude doesn't expose response directly
  "tool:before": ["PreToolUse"],
  "tool:after": ["PostToolUse"],
  "file:read": ["PreToolUse"], // Read tool
  "file:write": ["PreToolUse"], // Write tool
  "file:edit": ["PreToolUse"], // Edit tool
  "file:delete": ["PreToolUse"],
  "shell:before": ["PreToolUse"], // Bash tool
  "shell:after": ["PostToolUse"], // Bash tool
  "mcp:before": ["PreToolUse"],
  "mcp:after": ["PostToolUse"],
  notification: ["Notification"],
};

const REVERSE_MAP: Record<string, HookEventType[]> = {
  SessionStart: ["session:start"],
  UserPromptSubmit: ["prompt:submit"],
  PreToolUse: [
    "tool:before",
    "file:write",
    "file:edit",
    "file:delete",
    "shell:before",
    "mcp:before",
  ],
  PostToolUse: ["tool:after", "shell:after", "mcp:after"],
  Notification: ["notification"],
};

/**
 * Claude Code adapter for ai-hooks.
 *
 * Generates `.claude/settings.json` hook entries and shell scripts
 * that delegate to the ai-hooks runtime.
 */
class ClaudeCodeAdapter extends BaseAdapter {
  readonly id = "claude-code";
  readonly name = "Claude Code";
  readonly version = "1.0";

  readonly capabilities: AdapterCapabilities = {
    beforeHooks: true,
    afterHooks: true,
    mcp: true,
    configFile: true,
    supportedEvents: [
      "session:start",
      "prompt:submit",
      "tool:before",
      "tool:after",
      "file:read",
      "file:write",
      "file:edit",
      "file:delete",
      "shell:before",
      "shell:after",
      "mcp:before",
      "mcp:after",
      "notification",
    ],
    blockableEvents: [
      "prompt:submit",
      "tool:before",
      "file:write",
      "file:edit",
      "file:delete",
      "shell:before",
      "mcp:before",
    ],
  };

  async detect(): Promise<boolean> {
    // Check for claude CLI command
    const hasCommand = await this.commandExists("claude");

    // Also check for .claude directory (may not have CLI but has project config)
    const hasDir = existsSync(resolve(process.cwd(), ".claude"));

    return hasCommand || hasDir;
  }

  async generate(hooks: HookDefinition[]): Promise<GeneratedConfig[]> {
    const configs: GeneratedConfig[] = [];

    // 1. Generate the hook runner script
    configs.push(this.generateRunner());

    // 2. Generate the settings.json entries
    configs.push(await this.generateSettings(hooks));

    return configs;
  }

  mapEvent(event: HookEventType): string[] {
    return EVENT_MAP[event] ?? [];
  }

  mapNativeEvent(nativeEvent: string): HookEventType[] {
    return REVERSE_MAP[nativeEvent] ?? [];
  }

  async uninstall(): Promise<void> {
    await this.removeFile(".claude/hooks/ai-hooks-runner.js");
    // Note: we don't remove settings.json as it may have other user config
  }

  // -- Private Methods ---------------------------------------------

  /**
   * Generate the hook runner script that Claude Code hooks call.
   * This script loads the ai-hooks config and runs the appropriate chain.
   */
  private generateRunner(): GeneratedConfig {
    const script = `#!/usr/bin/env node
/**
 * ai-hooks runner for Claude Code.
 * Generated by: ai-hooks generate
 *
 * This script is called by Claude Code hooks. It loads your
 * ai-hooks.config.ts and runs the matching hook chain.
 *
 * DO NOT EDIT - regenerate with: ai-hooks generate
 */

import { loadConfig } from "@premierstudio/ai-hooks";
import { HookEngine } from "@premierstudio/ai-hooks";

const hookEvent = process.env.CLAUDE_HOOK_EVENT;
const toolName = process.env.CLAUDE_TOOL_NAME;
const inputJson = process.env.CLAUDE_TOOL_INPUT;

async function run() {
  const config = await loadConfig();
  const engine = new HookEngine(config);

  // Build the event from Claude Code's environment variables
  const event = buildEvent(hookEvent, toolName, inputJson);
  if (!event) {
    process.exit(0);
  }

  const toolInfo = { name: "claude-code", version: "1.0" };
  const results = await engine.emit(event, toolInfo);

  // Check for blocks
  const blocked = results.find((r) => r.blocked);
  if (blocked) {
    // Claude Code reads stdout JSON for hook results
    const output = JSON.stringify({
      decision: "block",
      reason: blocked.reason ?? "Blocked by ai-hooks",
    });
    process.stdout.write(output);
    process.exit(0);
  }

  process.exit(0);
}

function buildEvent(hookEvent, toolName, inputJson) {
  const timestamp = Date.now();
  const metadata = {};

  try {
    const input = inputJson ? JSON.parse(inputJson) : {};

    switch (hookEvent) {
      case "PreToolUse":
        return resolvePreToolUse(toolName, input, timestamp, metadata);
      case "PostToolUse":
        return resolvePostToolUse(toolName, input, timestamp, metadata);
      case "SessionStart":
        return {
          type: "session:start",
          tool: "claude-code",
          version: "1.0",
          workingDirectory: process.cwd(),
          timestamp,
          metadata,
        };
      case "UserPromptSubmit":
        return {
          type: "prompt:submit",
          prompt: input.prompt ?? "",
          timestamp,
          metadata,
        };
      default:
        return null;
    }
  } catch {
    return null;
  }
}

function resolvePreToolUse(toolName, input, timestamp, metadata) {
  switch (toolName) {
    case "Write":
      return {
        type: "file:write",
        path: input.file_path ?? "",
        content: input.content ?? "",
        timestamp,
        metadata,
      };
    case "Edit":
      return {
        type: "file:edit",
        path: input.file_path ?? "",
        oldContent: input.old_string ?? "",
        newContent: input.new_string ?? "",
        timestamp,
        metadata,
      };
    case "Bash":
      return {
        type: "shell:before",
        command: input.command ?? "",
        cwd: process.cwd(),
        timestamp,
        metadata,
      };
    default:
      return {
        type: "tool:before",
        toolName: toolName ?? "unknown",
        input: input ?? {},
        timestamp,
        metadata,
      };
  }
}

function resolvePostToolUse(toolName, input, timestamp, metadata) {
  switch (toolName) {
    case "Bash":
      return {
        type: "shell:after",
        command: input.command ?? "",
        cwd: process.cwd(),
        exitCode: input.exitCode ?? 0,
        stdout: input.stdout ?? "",
        stderr: input.stderr ?? "",
        duration: 0,
        timestamp,
        metadata,
      };
    default:
      return {
        type: "tool:after",
        toolName: toolName ?? "unknown",
        input: input ?? {},
        output: {},
        duration: 0,
        timestamp,
        metadata,
      };
  }
}

run().catch((err) => {
  console.error("[ai-hooks] Error:", err.message);
  process.exit(1);
});
`;

    return {
      path: ".claude/hooks/ai-hooks-runner.js",
      content: script,
      format: "js",
      gitignore: false,
    };
  }

  /**
   * Generate the Claude Code settings.json hook entries.
   */
  private async generateSettings(hooks: HookDefinition[]): Promise<GeneratedConfig> {
    // Read existing settings
    const settingsPath = ".claude/settings.json";
    let existing: Record<string, unknown> = {};

    const fullPath = resolve(process.cwd(), settingsPath);
    if (existsSync(fullPath)) {
      const raw = await readFile(fullPath, "utf-8");
      existing = JSON.parse(raw);
    }

    // Determine which Claude Code hook events we need
    const neededEvents = new Set<string>();
    for (const hook of hooks) {
      for (const event of hook.events) {
        const nativeEvents = this.mapEvent(event);
        for (const ne of nativeEvents) {
          neededEvents.add(ne);
        }
      }
    }

    // Build the hooks config
    // neededEvents is a Set, so each native event is processed exactly once.
    const hooksConfig: Record<string, unknown[]> = {};

    for (const event of neededEvents) {
      const hookEntry = {
        type: "command",
        command: `node .claude/hooks/ai-hooks-runner.js`,
        timeout: 10,
        description: `ai-hooks: ${event}`,
      };

      if (!hooksConfig[event]) {
        hooksConfig[event] = [];
      }
      (hooksConfig[event] as unknown[]).push({
        hooks: [hookEntry],
      });
    }

    // Merge with existing settings (preserve non-ai-hooks entries)
    const existingHooks = (existing.hooks ?? {}) as Record<string, unknown[]>;
    const mergedHooks: Record<string, unknown[]> = { ...existingHooks };

    for (const [event, entries] of Object.entries(hooksConfig)) {
      if (!mergedHooks[event]) {
        mergedHooks[event] = [];
      }
      // Remove old ai-hooks entries
      mergedHooks[event] = (
        mergedHooks[event] as Array<{ hooks?: Array<{ description?: string }> }>
      ).filter((entry) => !entry.hooks?.some((h) => h.description?.startsWith("ai-hooks:")));
      // Add new ai-hooks entries
      mergedHooks[event].push(...entries);
    }

    const mergedSettings = {
      ...existing,
      hooks: mergedHooks,
    };

    return {
      path: settingsPath,
      content: JSON.stringify(mergedSettings, null, 2) + "\n",
      format: "json",
      gitignore: false,
    };
  }
}

// Auto-register
const adapter = new ClaudeCodeAdapter();
registry.register(adapter);

export { ClaudeCodeAdapter };
export default adapter;
