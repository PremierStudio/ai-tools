import { BaseAdapter, registry } from "./index.js";
import type {
  AdapterCapabilities,
  GeneratedConfig,
  HookDefinition,
  HookEventType,
} from "../types/index.js";
import { existsSync } from "node:fs";
import { resolve } from "node:path";

/**
 * Event mapping: ai-hooks universal events -> Cursor native hooks.
 *
 * Cursor supports six lifecycle hooks (via .cursor/hooks.json):
 *   beforeSubmitPrompt, beforeShellExecution, beforeMCPExecution,
 *   beforeReadFile, afterFileEdit, stop
 *
 * Reference: https://docs.cursor.com/configuration/hooks
 */
const EVENT_MAP: Record<string, string[]> = {
  "session:start": [],
  "session:end": ["stop"],
  "prompt:submit": ["beforeSubmitPrompt"],
  "prompt:response": ["stop"],
  "tool:before": ["beforeMCPExecution"],
  "tool:after": [],
  "file:read": ["beforeReadFile"],
  "file:write": ["afterFileEdit"],
  "file:edit": ["afterFileEdit"],
  "file:delete": [],
  "shell:before": ["beforeShellExecution"],
  "shell:after": [],
  "mcp:before": ["beforeMCPExecution"],
  "mcp:after": [],
};

const REVERSE_MAP: Record<string, HookEventType[]> = {
  beforeSubmitPrompt: ["prompt:submit"],
  beforeShellExecution: ["shell:before"],
  beforeMCPExecution: ["tool:before", "mcp:before"],
  beforeReadFile: ["file:read"],
  afterFileEdit: ["file:write", "file:edit"],
  stop: ["session:end", "prompt:response"],
};

/**
 * Cursor adapter for ai-hooks.
 *
 * Generates `.cursor/hooks.json` with hook entries and a runner script.
 * Cursor hooks use a `{ "version": 1, "hooks": { ... } }` format.
 *
 * For blocking hooks (beforeShellExecution, beforeMCPExecution), the
 * runner outputs JSON with `{ "permission": "deny" }` to block execution.
 *
 * Reference: https://docs.cursor.com/configuration/hooks
 */
class CursorAdapter extends BaseAdapter {
  readonly id = "cursor";
  readonly name = "Cursor";
  readonly version = "1.0";

  readonly capabilities: AdapterCapabilities = {
    beforeHooks: true,
    afterHooks: true,
    mcp: true,
    configFile: true,
    supportedEvents: [
      "session:end",
      "prompt:submit",
      "prompt:response",
      "tool:before",
      "file:read",
      "file:write",
      "file:edit",
      "shell:before",
      "mcp:before",
    ],
    blockableEvents: ["shell:before", "mcp:before", "tool:before"],
  };

  async detect(): Promise<boolean> {
    const hasCommand = await this.commandExists("cursor");
    const hasDir = existsSync(resolve(process.cwd(), ".cursor"));
    return hasCommand || hasDir;
  }

  async generate(hooks: HookDefinition[]): Promise<GeneratedConfig[]> {
    const configs: GeneratedConfig[] = [];

    // Collect needed native events
    const neededEvents = new Set<string>();
    for (const hook of hooks) {
      for (const event of hook.events) {
        const nativeEvents = this.mapEvent(event);
        for (const ne of nativeEvents) {
          neededEvents.add(ne);
        }
      }
    }

    // Generate the runner script
    configs.push({
      path: ".cursor/hooks/ai-hooks-runner.js",
      content: this.generateRunner(),
      format: "js",
    });

    // Build Cursor hooks.json
    const hooksConfig: Record<string, unknown[]> = {};

    for (const event of neededEvents) {
      if (!hooksConfig[event]) {
        hooksConfig[event] = [];
      }
      hooksConfig[event].push({
        command: `node hooks/ai-hooks-runner.js ${event}`,
      });
    }

    configs.push({
      path: ".cursor/hooks.json",
      content: JSON.stringify({ version: 1, hooks: hooksConfig }, null, 2) + "\n",
      format: "json",
    });

    return configs;
  }

  mapEvent(event: HookEventType): string[] {
    return EVENT_MAP[event] ?? [];
  }

  mapNativeEvent(nativeEvent: string): HookEventType[] {
    return REVERSE_MAP[nativeEvent] ?? [];
  }

  async uninstall(): Promise<void> {
    await this.removeFile(".cursor/hooks/ai-hooks-runner.js");
    await this.removeFile(".cursor/hooks.json");
  }

  private generateRunner(): string {
    return `#!/usr/bin/env node
/**
 * ai-hooks runner for Cursor.
 * Generated by: ai-hooks generate
 *
 * Cursor passes the hook event name as a CLI argument.
 * Blocking hooks (beforeShellExecution, beforeMCPExecution)
 * return JSON: { "permission": "deny", "agentMessage": "reason" }
 *
 * DO NOT EDIT - regenerate with: ai-hooks generate
 */
import { loadConfig, HookEngine } from "@premierstudio/ai-hooks";

async function readStdin() {
  const chunks = [];
  for await (const chunk of process.stdin) {
    chunks.push(chunk);
  }
  return Buffer.concat(chunks).toString("utf-8");
}

async function run() {
  const hookEventName = process.argv[2] ?? "";
  let input = {};
  try {
    const raw = await readStdin();
    input = JSON.parse(raw || "{}");
  } catch {
    input = {};
  }

  const config = await loadConfig();
  const engine = new HookEngine(config);
  const toolInfo = { name: "cursor", version: "1.0" };
  const timestamp = Date.now();
  const metadata = {};

  let event;
  switch (hookEventName) {
    case "beforeSubmitPrompt":
      event = { type: "prompt:submit", prompt: input.prompt ?? "", timestamp, metadata };
      break;
    case "beforeShellExecution":
      event = { type: "shell:before", command: input.command ?? "", cwd: process.cwd(), timestamp, metadata };
      break;
    case "beforeMCPExecution":
      event = { type: "mcp:before", server: input.server ?? "", method: input.method ?? "", params: input.params ?? {}, timestamp, metadata };
      break;
    case "beforeReadFile":
      event = { type: "file:read", path: input.path ?? "", timestamp, metadata };
      break;
    case "afterFileEdit":
      event = { type: "file:edit", path: input.path ?? "", oldContent: "", newContent: "", timestamp, metadata };
      break;
    case "stop":
      event = { type: "session:end", tool: "cursor", duration: 0, timestamp, metadata };
      break;
    default:
      process.exit(0);
  }

  const results = await engine.emit(event, toolInfo);
  const blocked = results.find((r) => r.blocked);

  if (blocked) {
    const response = JSON.stringify({
      permission: "deny",
      agentMessage: blocked.reason ?? "Blocked by ai-hooks",
      userMessage: blocked.reason ?? "Blocked by ai-hooks",
    });
    process.stdout.write(response);
    process.exit(0);
  }

  if (hookEventName === "beforeShellExecution" || hookEventName === "beforeMCPExecution") {
    process.stdout.write(JSON.stringify({ permission: "allow" }));
  }
}

run().catch((err) => {
  console.error("[ai-hooks] Error:", err.message);
  process.exit(1);
});
`;
  }
}

// Auto-register
const adapter = new CursorAdapter();
registry.register(adapter);

export { CursorAdapter };
export default adapter;
